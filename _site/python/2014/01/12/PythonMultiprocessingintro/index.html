
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="ujianVerification" content="fbba4ee9b28ec33f11f17698ddc55b92" />
    <link rel="stylesheet" href="/pygments.css">
    <title>Python多进程模块Multiprocessing介绍</title>
    
    <meta name="author" content="Cloga Chen">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="/assets/themes/bootstrap/resources/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  
    <!--[if lt IE 9]>
      <script src="/assets/themes/bootstrap/resources/respond/Respond.min.js"></script>
    <![endif]-->

    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">
    <script>
      dataLayer = [];
    </script>
  </head>

  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">Cloga的互联网笔记</a>
        </div>

        <div class="collapse navbar-collapse navbar-ex1-collapse">
          <ul class="nav navbar-nav">
            
            
            


  
    
      
    
  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories.html">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">Pages</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  



          <li><a href="/about.html">关于Cloga</a></li>
          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
      
<div class="page-header">
  <h1>Python多进程模块Multiprocessing介绍 </h1>
</div>
<div class="row post-full">
  <div class="col-md-12">
    <div class="date">
      <span>12 January 2014</span>
    </div>
    <div class="content">
      <p><a href="http://docs.python.org/2/library/multiprocessing.html">Multiprocessing</a>是Python的
一个标准库，通过这个库，可以实现并行编程，更有效的利用多核CPU。由于Python的GIL的限制，默认情况下Python无法有效利用多核。通过Multiproc
essing，可以创建多个子线程，从而更加有效的利用多核。这篇文件会介绍一下使用Multiprocessing的线程池（Pool）实现简单的并行编程。</p>

<p>Multiprocessing类提供了Pool对象，通过进程池对象来管理和创建多个进程的worker，并收集这些Worker返回的结果。</p>

<h1>简单任务的多进程编程</h1>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="kn">as</span> <span class="nn">mul</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">factorial</span>
</code></pre></div>
<p>引入multiprocessiing，引入os模块用于查看进程id，引入阶乘计算，用于测试简单任务下的多进程编程。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">pool</span> <span class="o">=</span> <span class="n">mul</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>
<span class="n">mul</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">4</span>
</code></pre></div>
<p>上面的例子就实例化了一个进程池。Pool接受进程数作为参数，默认情况下，会使用cpu_count()的值作为进程的默认值。比如我的电脑的话，pool =
mul.Pool()等价于pool = mul.Pool(4)</p>

<p>让我们计算1-100的阶乘，返回一个list，用于测试多进程编程的效果。首先定义一个阶乘的函数。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_factorial</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pid</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;pid is&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</code></pre></div>
<p>为了显示当前所使用的进程，这里我们需要使用os.getpid()获得进程id。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">get_factorial</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">100000</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">29.1</span> <span class="err">µ</span><span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">f_10</span> <span class="o">=</span> <span class="n">get_factorial</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">pid</span> <span class="ow">is</span> <span class="mi">25566</span>
</code></pre></div>
<p>可以看到当前进程的PID。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">f_list_serial</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">pid</span><span class="o">=</span><span class="n">pid</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">results</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">f_list_serial</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">pid</span> <span class="ow">is</span> <span class="mi">27047</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27047</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27047</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27047</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27047</span>
</code></pre></div>
<p>定义个串行计算的函数，可以看到pid都是一个，说明计算是在一个进程中顺序进行的。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">f_list_serial</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">1000</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">594</span> <span class="err">µ</span><span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div>
<p>如果不使用并行计算的话，计算1-100的阶乘需要的时间是300-400µs左右。由于计算每个数字的阶乘任务之间都是独立的，因此可以使用简单的进程池来进程并行计算
。对于多个任务之间相互依赖或者需要共享信息的情况不在本文的讨论之中。将前面的串行计算改成用进程池来计算。</p>

<p>Multiprocessing提供了apply，apply<em>async，map和map</em>async等多种方法，用于线程池的计算。其中的map和apply与标准模
块中方法用法类似，所不同的是map只接受一个参数，如果需要接受多个参数则最好使用apply，而apply<em>async和map</em>async则是map和apply的
异步方法，其结果是异步返回的AsyncResult类型的数据。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">f_list_para_apply_async</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">pid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">pool</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mul</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>
    <span class="n">results_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">results_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">get_factorial</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">pid</span><span class="p">)))</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results_list</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">results</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">f_list_para_apply_async</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">pid</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">pid</span> <span class="ow">is</span> <span class="mi">27131</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27133</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27132</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27134</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27131</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27133</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27132</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27131</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27133</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27131</span>
</code></pre></div>
<p>如上所示，使用multiprocessing的进程池后可以看到不同的任务是在不同的进程中进程。</p>

<p>关于上面的函数有几点说明：</p>

<ul>
<li>在主程序中实例化pool会报错，而在函数中实例化则可以正常运行，这一点在Multiprocessing的官方文档中也有说明，官方文档的说法是这个包需要<strong>m
ain</strong>模块被子模块导入</li>
<li>apply_async支持多个参数，如果是位置参数，则可以使用args参数，值为tuple，如果是关键字参数，则可以使用kwds参数，值为字典，也可以同时使
用二者</li>
<li>当所有任务都执行完之后一定要记得用close()和join()回收进程，不然这些进程会变成僵尸进程，会造成打开文件过多的错误</li>
<li>每次apply_async返回的结果都是AsyncResult对象，需要通过get()方法获得其中的值。由于get()是阻塞的方式即同步的方式处理，因此，在
最后统一处理这些结果即可</li>
</ul>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f_list_para_apply_async</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">156</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div>
<p>通过timeit函数可以看到，使用默认的4个进程（基于我电脑目前的配置）计算时间有明显的增加。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f_list_para_apply_async</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="n">pool</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">165</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f_list_para_apply_async</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="n">pool</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">152</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div>
<p>尝试将进程增加到100或者将进程减少到1没有看到时间的明显变化，这可能是因为这个任务过于简单，使用多进程更多的资源浪费在进程切换上。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">f_list_para_map_asyns</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">results_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mul</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map_async</span><span class="p">(</span><span class="n">get_factorial</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results_list</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f_list_para_map_asyns</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">144</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div>
<p>使用map的异步形式获得计算速度的提升与apply<em>async相近，不过由于map</em>async只支持一个参数用途应该没有apply丰富。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">f_list_para_apply</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">pid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">pool</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mul</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">get_factorial</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">pid</span><span class="p">)))</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">results</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">r</span> <span class="o">=</span> <span class="n">f_list_para_apply</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">pid</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">pid</span> <span class="ow">is</span> <span class="mi">27343</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27344</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27345</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27346</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27343</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27344</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27345</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27346</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27343</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">27344</span>
</code></pre></div>
<p>使用map的非异步方式，仍然可以看到pid的变化，看来每个任务都是在不同的进程中进程，只是各个进程间不是并行进行而是顺序进行，必须要等到前一个进程计算完成返回了
结果，下一个进程才会开始进行计算。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f_list_para_apply</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">130</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div>
<p>对于阶乘这个例子，异步方式与同步方式的时间相近，这个应该是与选择的任务有关。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">f_list_para_map</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">results_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mul</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">get_factorial</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">r</span> <span class="o">=</span> <span class="n">f_list_para_apply</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">pid</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">pid</span> <span class="ow">is</span> <span class="mi">26642</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">26643</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">26644</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">26645</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">26642</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">26643</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">26644</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">26645</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">26642</span>
<span class="n">pid</span> <span class="ow">is</span> <span class="mi">26643</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f_list_para_map</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">166</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div>
<p>使用map的同步方式结果与apply的同步方式相近。</p>

<h1>复杂任务的多进程编程</h1>

<p>上面的例子可以看到对于比较简单，计算耗时较少的任务，使用多进程得不偿失，时间主要消耗在进程切换上无法提高计算效率。再来看一下耗时较长的任务使用多进程编程的效果如
何。</p>

<p>我们用抓取微博转发数据作为例子。帖子的例子选取了<a href="http://weibo.com/1496853872/AqSPp8Pyp">关于逸夫楼的一个热门微博</a>，mi
d为：3664072912104801，token使用微博给到的测试token。首先定义抓取微博转发数据的函数：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">token</span> <span class="o">=</span> <span class="s">&#39;2.00Hk5I5B0XUlu4bde500a7f8FHAqIB&#39;</span>
<span class="kn">import</span> <span class="nn">json</span><span class="o">,</span><span class="nn">urllib2</span><span class="o">,</span><span class="nn">urllib</span>
<span class="k">def</span> <span class="nf">get_repost_timeline</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">page</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">keys</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pid</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;pid&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span><span class="s">&#39;start!&#39;</span>
    <span class="n">query_args</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;id&#39;</span><span class="p">:</span> <span class="nb">id</span><span class="p">,</span> <span class="s">&#39;count&#39;</span><span class="p">:</span> <span class="n">count</span><span class="p">,</span> <span class="s">&#39;page&#39;</span><span class="p">:</span> <span class="n">page</span><span class="p">,</span>
                  <span class="s">&#39;access_token&#39;</span><span class="p">:</span> <span class="n">token</span><span class="p">}</span>
    <span class="n">query_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;https://api.weibo.com/2/statuses/repost_timeline.json?&#39;</span>
    <span class="n">encoded_args</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">urlencode</span><span class="p">(</span><span class="n">query_args</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span> <span class="o">+</span> <span class="n">encoded_args</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">pid</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;pid&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span><span class="s">&#39;finished!&#39;</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
</code></pre></div>
<p>具体文档见<a href="http://open.weibo.c%0Aom/wiki/2/statuses/repost_timeline">http://open.weibo.com/wiki/2/statuses/repost_timeline</a>。按照文档的说明，这个接口只返回最近2000条，每页默认返回200条结果，则可以循环10次
。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">get_repost_timeline</span><span class="p">(</span><span class="mi">3664072912104801</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">828</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div>
<p>可以看到获得200个转发需要的时间比较长，有1s左右。</p>

<p>接下来再定义两个函数一个是串行的方式抓取2000条转发，一个是异步并行方式抓取2000条转发。</p>

<p>首先是用串行的方式获得2000条转发：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_post_reposts</span><span class="p">(</span><span class="n">mid</span><span class="p">):</span>
    <span class="n">reposts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_number</span> <span class="o">=</span> <span class="n">get_repost_timeline</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">mid</span><span class="p">)[</span><span class="s">&#39;total_number&#39;</span><span class="p">]</span>
    <span class="n">page_number</span> <span class="o">=</span> <span class="n">total_number</span> <span class="o">/</span> <span class="mi">200</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">page_number</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">page_number</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">page_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">reposts</span> <span class="o">+=</span> <span class="n">get_repost_timeline</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">page</span><span class="o">=</span><span class="n">i</span><span class="p">)[</span><span class="s">&#39;reposts&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">reposts</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">get_post_reposts</span><span class="p">(</span><span class="mi">3664072912104801</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">10.2</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div>
<p>如果用串行的方式，抓取10页2000条转发需要的时间基本上是抓取一页转发的10倍，我们再来看一下用多进程编程的效果。这里首先使用异步的apply方式。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_post_reposts_para_async</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">pool_num</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">reposts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mul</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">pool_num</span><span class="p">)</span>
    <span class="n">total_number</span> <span class="o">=</span> <span class="n">get_repost_timeline</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">mid</span><span class="p">)[</span><span class="s">&#39;total_number&#39;</span><span class="p">]</span>
    <span class="n">page_number</span> <span class="o">=</span> <span class="n">total_number</span> <span class="o">/</span> <span class="mi">200</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">page_number</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">page_number</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">page_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">get_repost_timeline</span><span class="p">,</span> <span class="n">kwds</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">mid</span><span class="p">,</span> <span class="n">page</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="n">pid</span><span class="p">)))</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">reposts</span> <span class="o">+=</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()[</span><span class="s">&#39;reposts&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">reposts</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">reposts</span> <span class="o">=</span> <span class="n">get_post_reposts_para_async</span><span class="p">(</span><span class="mi">3664072912104801</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">pid 1687 start!
pid 1689 start!
pid 1688 start!
pid 1690 start!
pid 1687 finished!
pid 1689 finished!
pid 1688 finished!
pid 1690 finished!
pid 1687 start!
pid 1689 start!
pid 1688 start!
pid 1690 start!
pid 1687 finished!
pid 1689 finished!
pid 1688 finished!
pid 1690 finished!
pid 1687 start!
pid 1689 start!
pid 1687 finished!
pid 1689 finished!
</code></pre></div>
<p>每个pid是并行进行的，一个进程开始后，其他的进程也可以同步开始。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">get_post_reposts_para_async</span><span class="p">(</span><span class="mi">3664072912104801</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">7.64</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">get_post_reposts_para_async</span><span class="p">(</span><span class="mi">3664072912104801</span><span class="p">,</span> <span class="n">pool_num</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">7.64</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">get_post_reposts_para_async</span><span class="p">(</span><span class="mi">3664072912104801</span><span class="p">,</span> <span class="n">pool_num</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">10.3</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">get_post_reposts_para_async</span><span class="p">(</span><span class="mi">3664072912104801</span><span class="p">,</span> <span class="n">pool_num</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">8.24</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div>
<p>从运行时间来看，似乎是随着进程池的增加而减少，达到10次，即这个任务的每个循环任务都有一个单独的进程达到一个峰值，之后运行时间会减少。但是总体来说，异步的多进程
编程比串行的时间要少。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_post_reposts_para</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">pool_num</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">reposts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mul</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">pool_num</span><span class="p">)</span>
    <span class="n">total_number</span> <span class="o">=</span> <span class="n">get_repost_timeline</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">mid</span><span class="p">)[</span><span class="s">&#39;total_number&#39;</span><span class="p">]</span>
    <span class="n">page_number</span> <span class="o">=</span> <span class="n">total_number</span> <span class="o">/</span> <span class="mi">20</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">page_number</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">page_number</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">page_number</span><span class="p">):</span>
        <span class="n">reposts</span> <span class="o">+=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">get_repost_timeline</span><span class="p">,</span><span class="n">kwds</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">mid</span><span class="p">,</span> <span class="n">page</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="n">pid</span><span class="p">))[</span><span class="s">&#39;reposts&#39;</span><span class="p">]</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">reposts</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">reposts</span> <span class="o">=</span> <span class="n">get_post_reposts_para</span><span class="p">(</span><span class="mi">3664072912104801</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">pid 2206 start!
pid 2206 finished!
pid 2207 start!
pid 2207 finished!
pid 2208 start!
pid 2208 finished!
pid 2209 start!
pid 2209 finished!
pid 2206 start!
pid 2206 finished!
pid 2207 start!
pid 2207 finished!
pid 2208 start!
pid 2208 finished!
pid 2209 start!
pid 2209 finished!
pid 2206 start!
pid 2206 finished!
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">get_post_reposts_para</span><span class="p">(</span><span class="mi">3664072912104801</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">9.04</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">get_post_reposts_para</span><span class="p">(</span><span class="mi">3664072912104801</span><span class="p">,</span><span class="n">pool_num</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">9.87</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">timeit</span> <span class="n">get_post_reposts_para</span><span class="p">(</span><span class="mi">3664072912104801</span><span class="p">,</span><span class="n">pool_num</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">9.71</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div>
<p>由于是非异步的形式，每个进程的任务完成后才会启动新的进程，不过从运行时间上来看，还是要比串行的形式时间要短。你也可以查看<a href="http://nbviewer.ipython.org/gist/cloga/8382454">这篇文章的ipython notebook版本</a>。</p>

    </div>

    
      <ul class="tag_box inline">
        <li><i class="icon-folder-open"></i></li>
        
        


  
     
    	<li><a href="/categories.html#python-ref">
    		python <span>17</span>
    	</a></li>
    
  


      </ul>
    

    
      <ul class="tag_box inline">
        <li><i class="icon-tags"></i></li>
        
        


  
     
    	<li><a href="/tags.html#Multiprocessing-ref">Multiprocessing <span>1</span></a></li>
     
    	<li><a href="/tags.html#Python-ref">Python <span>17</span></a></li>
    
  



      </ul>
    

    <hr>
    
    <ul class="pagination">
      
        <li class="prev"><a href="/python/2014/01/02/Orangeintro" title="开源数据挖掘工具Orange简介">&larr; 上一页</a></li>
      
        <li><a href="/archive.html">归档列表</a></li>
      
        <li class="next"><a href="/2014/01/19/sklearn_text_feature_extraction" title="sklearn文本特征提取">下一页 &rarr;</a></li>
      
    </ul>
    <hr>
    <!-- Paste the 3 next lines where you want the sharing button(s) to appear -->
    <div class="post-sharing">
     


  <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
	<span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_tools_1"></a>
	<a class="jiathis_button_tools_2"></a>
	<a class="jiathis_button_tools_3"></a>
	<a class="jiathis_button_tools_4"></a>
	<a href="http://www.jiathis.com/share?uid=1654363" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1343300786690926" charset="utf-8"></script>
<!-- JiaThis Button END -->



    </div>    
    <div class="post-comments">
    


  <!-- UJian Button BEGIN -->
<div class="ujian-hook"></div>
<script type="text/javascript">var ujian_config = {num:12,picSize:84,textHeight:45};</script>
<script type="text/javascript" src="http://v1.ujian.cc/code/ujian.js?uid=1654363"></script>
<a href="http://www.ujian.cc" style="border:0;"><img src="http://img.ujian.cc/pixel.png" alt="友荐云推荐" style="border:0;padding:0;margin:0;" /></a>
<!-- UJian Button END -->
<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1654363"></script>
<!-- UY END -->



    </div>
  </div>
</div>


      <hr>
      <footer>
        <p>
          &copy; 2014 Cloga Chen
          <span class="pull-right text-muted">
            powered by
            <a href="http://jekyll-bootstrap-3.github.io" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll-Bootstrap-3</a>
            and <a href="http://getbootstrap.com" target="_blank">Twitter Bootstrap 3.0.3</a>
          </span>
        </p>
      </footer>
    </div>

    
    <script src="/assets/themes/bootstrap/resources/jquery/jquery.min.js"></script>
    <script src="/assets/themes/bootstrap/resources/bootstrap/js/bootstrap.min.js"></script>
<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-7VF4"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-7VF4');</script>
<!-- End Google Tag Manager -->


  </body>
</html>

